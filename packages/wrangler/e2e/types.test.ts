import { readFileSync } from "node:fs";
import { readFile, writeFile } from "node:fs/promises";
import path from "node:path";
import { describe, expect, it } from "vitest";
import { dedent } from "../src/utils/dedent";
import { WranglerE2ETestHelper } from "./helpers/e2e-wrangler-test";

const seed = {
	"wrangler.toml": dedent`
		name = "test-worker"
		main = "src/index.ts"
		compatibility_date = "2023-01-01"
		compatibility_flags = ["nodejs_compat", "no_global_navigator"]
	`,
	"src/index.ts": dedent`
		export default {
			fetch(request) {
				return new Response("Hello World!")
			}
		}
	`,
	"package.json": dedent`
		{
			"name": "test-worker",
			"version": "0.0.0",
			"private": true
		}
	`,
};

describe("types", () => {
	it("should generate runtime types without a flag", async () => {
		const helper = new WranglerE2ETestHelper();
		await helper.seed(seed);
		const output = await helper.run(`wrangler types`);

		expect(output.stdout).toContain("Generating runtime types...");
		expect(output.stdout).toContain("Runtime types generated.");
		expect(output.stdout).toContain(
			"âœ¨ Types written to worker-configuration.d.ts"
		);
		expect(output.stdout).toContain("ðŸ“– Read about runtime types");
	});

	it("should generate runtime types and env types in one file at the default path", async () => {
		const helper = new WranglerE2ETestHelper();
		await helper.seed(seed);
		const output = await helper.run(`wrangler types`);
		expect(output.stdout).toContain("Generating project types...");
		expect(output.stdout).toContain("interface Env {");
		expect(output.stdout).toContain("Generating runtime types...");
		expect(output.stdout).toContain("Runtime types generated.");
		expect(output.stdout).toContain(
			"âœ¨ Types written to worker-configuration.d.ts"
		);
		const file = readFileSync(
			path.join(helper.tmpPath, "./worker-configuration.d.ts"),
			"utf8"
		);
		expect(file).contains('declare module "cloudflare:workers"');
		expect(file).contains("interface Env");
	});

	it("should include header with version information in the generated types", async () => {
		const helper = new WranglerE2ETestHelper();
		await helper.seed(seed);
		await helper.run(`wrangler types "./types.d.ts" `);

		const file = (await readFile(path.join(helper.tmpPath, "./types.d.ts")))
			.toString()
			.split("\n");

		expect(file[0]).toMatchInlineSnapshot(
			`"// Generated by Wrangler by running \`wrangler types ./types.d.ts\`"`
		);
		expect(file[1]).match(
			/\/\/ Runtime types generated with workerd@1\.\d+\.\d \d\d\d\d-\d\d-\d\d ([a-z_]+,?)*/
		);
	});

	it("should not regenerate runtime types if the header matches, but should regenerate env types", async () => {
		const helper = new WranglerE2ETestHelper();
		await helper.seed(seed);
		await helper.run(`wrangler types`);

		const typesPath = path.join(helper.tmpPath, "worker-configuration.d.ts");
		const file = (await readFile(typesPath)).toString().split("\n");

		await writeFile(
			typesPath,
			[
				file[0],
				file[1],
				"FAKE ENV",
				"// Begin runtime types",
				"FAKE RUNTIME",
			].join("\n")
		);
		console.log(
			[
				file[0],
				file[1],
				"FAKE ENV",
				"// Begin runtime types",
				"FAKE RUNTIME",
			].join("\n")
		);

		await helper.run(`wrangler types`);

		const file2 = (await readFile(typesPath)).toString();

		expect(file2).toMatchInlineSnapshot(`
			"// Generated by Wrangler by running \`wrangler types\`
			// Runtime types generated with workerd@1.20250204.0 2023-01-01 nodejs_compat,no_global_navigator
			// eslint-disable-next-line @typescript-eslint/no-empty-interface,@typescript-eslint/no-empty-object-type
			interface Env {
			}

			// Begin runtime types
			FAKE RUNTIME"
		`);
	});
});
